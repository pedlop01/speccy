// Class automatically generated by Dev-C++ New Class wizard

#include "world.h" // class's header file

// class constructor
World::World()
{
}

World::World(const char *file, bool tileExtractedOption)
{
  // REVISIT: need to read collision map
  char aux_file[100];
  char tileset_file[100];

  pugi::xml_parse_result result = world_file.load_file(file);

  if(!result) {
      printf("Error: loading world data\n");      
  }  

  pugi::xml_node map = world_file.child("map");

  map_width = map.attribute("width").as_int();
  map_height = map.attribute("height").as_int();
  tileset_width = map.attribute("tilewidth").as_int();
  tileset_height = map.attribute("tileheight").as_int();

  pugi::xml_node tileset = world_file.child("map").child("tileset");

  sprintf(aux_file, "%s", file);
  sprintf(tileset_file, "%s/%s", chopToDirectory(aux_file).c_str(), tileset.attribute("name").as_string());

  printf("Tileset file = %s\n", tileset_file);

  world_image = al_load_bitmap(tileset_file);
  if (!world_image) {
    printf("Error: failed to load tileset\n");    
  }

  tileset_count = tileset.attribute("tilecount").as_int();
  tileset_columns = tileset.attribute("columns").as_int();
  tileset_tile_width = tileset.attribute("tilewidth").as_int();
  tileset_tile_height = tileset.attribute("tileheight").as_int();

  printf("Tileset count = %d\nTileset columns = %d\nTile width = %d\nTile height = %d\n", tileset_count, tileset_columns, tileset_tile_width, tileset_tile_height);
  
  // Initialize world    
  world_tiles = new Tile**[map_width];
  
  for (int x = 0 ; x < map_width ; x++ ) {
      world_tiles[x] = new Tile*[map_height];
      for (int y = 0 ; y < map_height ; y++ ) {
          world_tiles[x][y] = new Tile();
      }
  }

  // First initialize tiles
  // Tile properties is a layer of same size as tiles, so we can reuse the for stament
  // for both of them. REVISIT: add check to verify they have same size?
  pugi::xml_node xml_tile = world_file.child("map").find_child_by_attribute("layer", "name", "Tiles").child("data");
  pugi::xml_node xml_tile_prop = world_file.child("map").find_child_by_attribute("layer", "name", "Collisions").child("data");

  int x = 0;
  int y = 0;
  pugi::xml_node prop = xml_tile_prop.first_child();
  for (pugi::xml_node tile = xml_tile.first_child(); tile; tile = tile.next_sibling()) {
    pugi::xml_attribute tile_attr = tile.first_attribute();
    pugi::xml_attribute prop_attr = prop.first_attribute();

    int tile_id = ((tile_attr.as_int() != 0) ? tile_attr.as_int() - 1: tile_attr.as_int());
    int tile_prop = ((prop_attr.as_int() != 0) ? prop_attr.as_int() - 1: prop_attr.as_int());
    // Save the id of the tile aswell as the coordinates in the tileset bitmap
    world_tiles[x][y]->SetValue(tile_id);
    world_tiles[x][y]->SetType(tile_prop);
    world_tiles[x][y]->SetLeftUpX((tile_id % tileset_columns) * tileset_width);
    world_tiles[x][y]->SetLeftUpY(ceil(tile_id/tileset_columns)*tileset_height);
    world_tiles[x][y]->SetRightDownX((tile_id % tileset_columns) * tileset_width + tileset_width);
    world_tiles[x][y]->SetRightDownY(ceil((tile_id/tileset_columns))*tileset_height + tileset_height);
    if (x == (map_width - 1)) {
      y++;
      x = 0;
    } else {
      x++;
    }
    // Move prop pointer
    prop = prop.next_sibling();
  }

  // Read platforms
  // REVISIT: need to be read from file! refactor reading of map too!
  Platform* platform1 = new Platform("../designs/platforms/platforms.xml", 804, 1720, 24, 8, true, true, OBJ_DIR_UP,    10*8);
  Platform* platform2 = new Platform("../designs/platforms/platforms.xml", 548, 1368, 24, 8, true, true, OBJ_DIR_DOWN,  14*8);
  Platform* platform3 = new Platform("../designs/platforms/platforms.xml", 450, 1696, 24, 8, true, true, OBJ_DIR_LEFT,  20*8);
  Platform* platform4 = new Platform("../designs/platforms/platforms.xml", 300, 1696, 24, 8, true, true, OBJ_DIR_RIGHT, 20*8);
  Platform* platform5 = new Platform("../designs/platforms/platforms.xml", 972,  992, 24, 8, true, true, OBJ_DIR_LEFT,   6*8);
  Platform* platform6 = new Platform("../designs/platforms/platforms.xml", 708, 1200, 24, 8, true, true, OBJ_DIR_UP,    12*8);
  Platform* platform7 = new Platform("../designs/platforms/platforms.xml", 288, 1640, 24, 8, true, true, OBJ_DIR_UP,    10*8);
  Platform* platform8 = new Platform("../designs/platforms/platforms.xml", 452, 1568, 24, 8, true, true, OBJ_DIR_UP,    13*8);
  Platform* platform9 = new Platform("../designs/platforms/platforms.xml", 484, 1320, 24, 8, true, true, OBJ_DIR_UP,    13*8);
  Platform* platform10 = new Platform("../designs/platforms/platforms.xml", 388, 1048, 24, 8, true, true, OBJ_DIR_UP,   12*8);
  platforms.push_back(platform1);
  platforms.push_back(platform2);
  platforms.push_back(platform3);
  platforms.push_back(platform4);
  platforms.push_back(platform5);
  platforms.push_back(platform6);
  platforms.push_back(platform7);
  platforms.push_back(platform8);
  platforms.push_back(platform9);
  platforms.push_back(platform10);

  // REVISIT: adding objects manually
  Item* object1 = new Item();
  object1->Init("../designs/items/shoots.xml", 350, 1920, 20, 18, true, true, OBJ_STATE_STOP, OBJ_DIR_STOP, 0.1, 3.0, 1.0, 0.1, 3.0, 1.0);
  objects.push_back(object1);
  Item* object2 = new Item();
  object2->Init("../designs/items/shoots.xml", 380, 1920, 20, 18, true, true, OBJ_STATE_STOP, OBJ_DIR_STOP, 0.1, 3.0, 1.0, 0.2, 5.0, 1.0);    
  objects.push_back(object2);

  // REVISIT: adding lasers manually
  Laser* laser1 = new Laser("../designs/lasers/laser_horizontal.xml", 264, 1980, 26, 6, LASER_TYPE_RECURSIVE, 5.0, OBJ_DIR_RIGHT);
  objects.push_back(laser1);
}

// class destructor
World::~World()
{
  // Delete tiles
//  for( int i = 0 ; i < tiles_m_y ; i++ ) {
//    for( int j = 0 ; j < tiles_m_x ; j++ ) {
//      delete tiles_mundo[i][j];
//    }
//    delete tiles_mundo[i];
//  }
//  delete tiles_mundo;
//    
//  al_destroy_bitmap(world_image);

  // Destroy platforms
  for (vector<Platform*>::iterator it = platforms.begin() ; it != platforms.end(); ++it) {
      delete *it;
  }
  for (list<Object*>::iterator it = objects.begin() ; it != objects.end(); ++it) {
      delete *it;
  }
}

int World::GetMapWidth() {
   return map_width;
}

int World::GetMapHeight() {
  return map_height;
}

int World::GetTilesetWidth() {
  return tileset_width;
}

int World::GetTilesetHeight() {
  return tileset_height;
}

int World::GetTilesetCount() {
  return tileset_count;
}

int World::GetTilesetColumns() {
  return tileset_columns;
}

int World::GetTilesetTileWidth() {
  return tileset_tile_width;
}

int World::GetTilesetTileHeight() {
  return tileset_tile_height;
}

Tile* World::GetTile(int x, int y) {
  return world_tiles[x][y];
}

int World::GetTileValue(int x, int y) {
  return world_tiles[x][y]->GetValue();
}

int World::GetTileValueByCoord(int x, int y)
{
  int tile_x = x / tileset_tile_width;
  int tile_y = y / tileset_tile_height;

  return world_tiles[tile_x][tile_y]->GetValue();
}

Tile* World::GetTileByCoord(int x, int y)
{
  int tile_x = x / tileset_tile_width;
  int tile_y = y / tileset_tile_height;

  return world_tiles[tile_x][tile_y];
}

void World::WorldStep(Character* player) {
  // Perform an step of all elements belonging to the world level
  for (vector<Platform*>::iterator it = platforms.begin() ; it != platforms.end(); ++it) {
      (*it)->PlatformStep();
  }

  for (list<Object*>::iterator it = objects.begin() ; it != objects.end(); ++it) {
    Object* object = *it;
    if (object->GetState() == OBJ_STATE_DEAD) {
      printf("Object dead %d\n", object->GetId());
      switch (object->GetType()) {
        case OBJ_ITEM:
          delete ((Item*)object);
          break;
        default:
          printf("[WARNING] Unknown object type to be deleted in World!\n");
          break;
      }
      objects.erase(it);                            // Remove element if it is dead.
    } else if (object->GetActive()) {
      //printf("Object active id = %d, type = %d\n", object->GetId(), object->GetType());
      switch (object->GetType()) {
        case OBJ_ITEM:
          ((Item*)object)->ObjectStep(this, player);
          break;
        case OBJ_LASER:
          ((Laser*)object)->ObjectStep(this, player);
          break;          
        default:
          break;
      }
    } else {
      printf("Object inactive %d\n", object->GetId());
    }
  }
}
