// Class automatically generated by Dev-C++ New Class wizard

#include "character.h" // class's header file

// class constructor
character::character(symbolTablePtr _symbolTable, fxHandler* _soundHandler)
{
    am_i_a_frog = false;
                                          
    // load animations
    this->loadAnimations("./data/characters/warrior.txt");
    stateHandler.openDefinitionFile("./data/characters/warrior_def_states.txt");
    this->SetInitialState();    

    symbTable = _symbolTable;
    soundHandler = _soundHandler;

    warrior_sentido = WARRIOR_SENTIDO_DERECHA;    
     
    carrying_object = 0; 
    offered_object = 0; 
    
    forceStateUpdate = 0;
    keepMoving = 0;
    
    state_change_fx = false;
}

// class destructor
character::~character()
{
	// insert your code here
}

void character :: AddInternalVarsToSymbTable()
{
    symbTable->addVarToSymbolTable("forceStateUpdate", (unsigned long*)&forceStateUpdate);              
    symbTable->addVarToSymbolTable("keepMoving", (unsigned long*)&keepMoving);                  
    symbTable->addVarToSymbolTable("previous_state", (unsigned long*)&previous_state);         
    symbTable->addVarToSymbolTable("current_state", (unsigned long*)&current_state);    
    symbTable->addVarToSymbolTable("carrying_object", (unsigned long*)&carrying_object);
    symbTable->addVarToSymbolTable("offered_object", (unsigned long*)&offered_object);    
    symbTable->addVarToSymbolTable("am_i_a_frog", (unsigned long*)&am_i_a_frog);     
}

void character :: SetInitialState()
{
    if( am_i_a_frog == false )
    {
        current_state   = WARRIOR_CAYENDO;
        previous_state  = WARRIOR_CAMINANDO;
        stateHandler.ForceCurrentState(current_state, previous_state);
    }
    else
    {
        current_state   = WARRIOR_RANA_CAYENDO;
        previous_state  = WARRIOR_RANA_CAMINANDO;        
        stateHandler.ForceCurrentState(current_state, previous_state);        
    }

    contact_down = false;
    
    mseg_chk = 0;
    mseg_chk_anim = 0;

    subAnimacion = 0;    
    currentSprite = animacion[current_state].sprites.begin();  
    
    jumpTime = 0;  
}

void character :: SetInitialState(int currentState, int prevState)
{
    current_state   = currentState;
    previous_state  = prevState;
    stateHandler.ForceCurrentState(current_state, previous_state);

    contact_down = false;
    
    mseg_chk = 0;
    mseg_chk_anim = 0;

    subAnimacion = 0;    
    currentSprite = animacion[current_state].sprites.begin();  
    
    jumpTime = 0;  
}

void character :: computeNewPositionUsingCurrentState(mundo *world, int entrada_teclado, float &x, float &y)
{
    // Calculamos la nueva posicion segun los inputs de teclado
    if( (current_state == WARRIOR_CAMINANDO || current_state == WARRIOR_SALTANDO || current_state == WARRIOR_CAYENDO ||
        current_state == WARRIOR_RANA_CAMINANDO || current_state == WARRIOR_RANA_SALTANDO || current_state == WARRIOR_RANA_CAYENDO) && warrior_sentido == WARRIOR_SENTIDO_DERECHA )    // RIGHT
    {
         // Excepcion
         if( ((current_state == WARRIOR_CAYENDO) && (previous_state == WARRIOR_CAMINANDO)) ||
             ((current_state == WARRIOR_RANA_CAYENDO) && (previous_state == WARRIOR_RANA_CAMINANDO)) )
         {            
         }
         else
         {
             if( x + 1 > world->GetScreenNewX() - world->GetTileSizeRatio()*(*currentSprite)->xSize ) 
             {
                 x = world->GetScreenNewX() - world->GetTileSizeRatio()*(*currentSprite)->xSize;
             }
             else
             {
                     x += 1; 
             }
         }
    }
    if( (current_state == WARRIOR_CAMINANDO || current_state == WARRIOR_SALTANDO || current_state == WARRIOR_CAYENDO ||
        current_state == WARRIOR_RANA_CAMINANDO || current_state == WARRIOR_RANA_SALTANDO || current_state == WARRIOR_RANA_CAYENDO) && warrior_sentido == WARRIOR_SENTIDO_IZQUIERDA )   // LEFT
    {
        // Excepcion
         if( (current_state == WARRIOR_CAYENDO && previous_state == WARRIOR_CAMINANDO) ||
             (current_state == WARRIOR_RANA_CAYENDO && previous_state == WARRIOR_RANA_CAMINANDO) )
         {                
         }
         else
         {
             if( (x - 1) < 0 )
             {
                 x = 0;
             }
             else
             {
                     x -= 1;
             }
         }
    }
    if( current_state == WARRIOR_SALTANDO || current_state == WARRIOR_RANA_SALTANDO )   // UP
    {
         if( y - 1 < 0 )
             y = 0;
         else
         {
             y -= 1;
         }
    }    
    
    if( current_state == WARRIOR_CAYENDO || current_state == WARRIOR_RANA_CAYENDO)   // DOWN
    {
         if( y + 1 > world->GetScreenNewY() - world->GetTileSizeRatio()*(*currentSprite)->xSize )
         {
             y = world->GetScreenNewY() - world->GetTileSizeRatio()*(*currentSprite)->xSize;
         }
         else
         {         
             y += 1;
         }
    }

    // Al subir o bajar escaleras hay que ajustar al personaje en el primer escalón
    if( (current_state == WARRIOR_EN_ESCALERAS_LEFT_CAMINANDO) && 
        (previous_state == WARRIOR_CAMINANDO) &&
        (stateHandler.GetTransitionDone())  )
    {
        if( warrior_sentido == WARRIOR_SENTIDO_IZQUIERDA )
        {
            x += (world->GetTilesSizeX() - ((int)x % world->GetTilesSizeX())) - 1;
        }
        else
        {
            x = x - (((int)x % world->GetTilesSizeX())) - 1;
        }
    }
    
    if( current_state == WARRIOR_EN_ESCALERAS_LEFT_CAMINANDO )
    {
        if( entrada_teclado & LEFT )
        {
            x--;
            y--;
        }
        if( entrada_teclado & RIGHT )
        {
            x++;
            y++;
        }
    }
}

void character :: handleState(int entrada_teclado, unsigned int mseg_global)
{   
    // Fx sounds
    if( current_state == WARRIOR_GOLPEANDO && previous_state != WARRIOR_GOLPEANDO )
    {
        if( !soundHandler->getEnabled(1) )
        {
            soundHandler->setEnabled(1, true);
            soundHandler->playSound(1);
        }
    }
    else
    {
        soundHandler->setEnabled(1, false); 
    }
    
    if( current_state == WARRIOR_CAMINANDO )
    {
        if( !soundHandler->getEnabled(2) )
        {
            soundHandler->setEnabled(2, true);     
            soundHandler->playSound(2);
        }
    }
    else
    {
        soundHandler->setEnabled(2, false);     
    }

    if( current_state == WARRIOR_RANA_CAMINANDO )
    {
        if( !soundHandler->getEnabled(8) )
        {
            soundHandler->setEnabled(8, true);     
            soundHandler->playSound(8);
        }
    }
    else
    {
        soundHandler->setEnabled(8, false);     
    }

    
    if( current_state == WARRIOR_AGACHADO && previous_state == WARRIOR_CAYENDO )
    {
        if( !soundHandler->getEnabled(3) )
        {
            soundHandler->setEnabled(3, true);
            soundHandler->playSound(3);
        }
    }
    else
    {
        soundHandler->setEnabled(3, false); 
    }
        
    if( current_state != WARRIOR_CAMINANDO )
    {
        soundHandler->stopSound(2);
    }    
    // End Fx Sounds
        
    // Special case for frog conversion
    if( (am_i_a_frog == true) && (stateHandler.GetCurrentState() < 12) ) // FIXME
    {
        subAnimacion = 0;
        stateHandler.ForceCurrentState(WARRIOR_RANA_PARADO, WARRIOR_RANA_PARADO);
    }
    if( forceStateUpdate )
    {
         stateHandler.ForceCurrentState(current_state, previous_state);
    }
    else
    {
        // This situation is only forced via scripting
        // It keeps the charater moving regardeless the situation
        // This is very useful to fix scroll zones movements or
        // to put the character in automatically in a map position
        if( keepMoving )
        {
            if( contact_down && (entrada_teclado == NO_KEY) )
            {
                if( warrior_sentido == WARRIOR_SENTIDO_IZQUIERDA )
                    entrada_teclado = LEFT;
                else
                    entrada_teclado = RIGHT;
            }
        }
        // call stateHandler
        stateHandler.handleState(entrada_teclado, mseg_global, contact_down, 
                                 en_escaleras_left, en_escaleras_right, 
                                 current_x, current_y, current_x_ant, current_y_ant);
    }

    // Update vars using stateHandler modifications
    current_state   = stateHandler.GetCurrentState();
    previous_state  = stateHandler.GetPreviousState();
    warrior_sentido = stateHandler.GetDirection();
    
    // subAnimation must be reset every state transition
    if( stateHandler.GetTransitionDone() /*&& !forceStateUpdate*/ )
    {
        subAnimacion = 0;
    }

    forceStateUpdate = 0;    
}

void character :: computeNewPositionUsingCollisionDetection(mundo *world, int entrada_teclado, float &x, float &y, unsigned int mseg_global)
{
    float x_ant = x;
    float y_ant = y;

    en_escaleras_left = false;
    en_escaleras_right = false;

    this->computeNewPositionUsingCurrentState(world, entrada_teclado, x, y);
    this->computeNextAnimationSprite(mseg_global);

//    assert( x != x_ant || y != y_ant );

    // Deteccion de colisiones con la nueva posicion y computo de una posicion segura
    // en caso de colision
    unsigned int col_right = false;
    unsigned int col_left  = false;
    unsigned int col_up    = false;
    unsigned int col_down  = false;

    if( x != x_ant )
    {
        if( x > x_ant )
        {
             for( int i = y + 1 ; (i < y + world->GetTileSizeRatio()*(*currentSprite)->ySize - 1) && !col_right ; i++ )    
             {
                 col_right = world->GetTileByCoord(x + world->GetTileSizeRatio()*(*currentSprite)->xSize, i)->GetCollisionable();
             }
        }
        else
        {
             for( int i = y + 1 ; (i < y + world->GetTileSizeRatio()*(*currentSprite)->ySize - 1) && !col_left ; i++ )     
             {
                 col_left = world->GetTileByCoord(x, i)->GetCollisionable();
             }
        }
    }
    if( y != y_ant )
    {
        if( y > y_ant )
        {
             for( int i = x + 1 ; (i < x + world->GetTileSizeRatio()*(*currentSprite)->xSize - 1) && !col_down ; i++ )     
             {
                 col_down = world->GetTileByCoord(i, y + world->GetTileSizeRatio()*(*currentSprite)->ySize - 1)->GetCollisionable();
             }
        }
        else
        {
             for( int i = x + 1 ; (i < x + world->GetTileSizeRatio()*(*currentSprite)->xSize - 1) && !col_up ; i++ )       
             {
                 col_up = world->GetTileByCoord(i, y)->GetCollisionable();
             }
        }
    }

    // Tratamiento con tiles completamente colisionables
    if( (col_left == TILE_COLISIONABLE) || (col_right == TILE_COLISIONABLE) )
    {
        x = x_ant;
    }
    if( (col_up == TILE_COLISIONABLE) || (col_down == TILE_COLISIONABLE) )
    {
        y = y_ant;
    }
    
    // Tratamiento para tiles de pendiente   
    if( (world->GetTileByCoord(x, y + world->GetTileSizeRatio()*((*currentSprite)->ySize) - 1)->GetCollisionable() == TILE_PENDIENTE_IZQUIERDA) && (warrior_sentido == WARRIOR_SENTIDO_IZQUIERDA) )
    {
        en_escaleras_left = true;
    }    
    if( (world->GetTileByCoord(x, y + world->GetTileSizeRatio()*((*currentSprite)->ySize) + 1)->GetCollisionable() == TILE_PENDIENTE_IZQUIERDA) && (warrior_sentido == WARRIOR_SENTIDO_DERECHA) )    
    {
        en_escaleras_left = true;
    }
    if( (world->GetTileByCoord(x + world->GetTileSizeRatio()*((*currentSprite)->xSize) - 1, y + world->GetTileSizeRatio()*((*currentSprite)->ySize) - 1)->GetCollisionable() == TILE_PENDIENTE_DERECHA) && (warrior_sentido == WARRIOR_SENTIDO_DERECHA) )
    {
        en_escaleras_right = true;
    }    
    

    // Queremos saber si estamos en contacto con el suelo
    contact_down = false; 
    for( int i = x ; (i < x + world->GetTileSizeRatio()*(*currentSprite)->xSize) && !contact_down ; i++ )    
    {
        contact_down = (world->GetTileByCoord(i, y + world->GetTileSizeRatio()*(*currentSprite)->ySize)->GetCollisionable() == TILE_COLISIONABLE);   
    } 

    // Queremos saber si golpeamos con la cabeza algo
    contact_up = false;
    for( int i = x ; (i < x + world->GetTileSizeRatio()*(*currentSprite)->xSize) && !contact_up ; i++ )    
    {
        contact_up = (world->GetTileByCoord(i, y - 1)->GetCollisionable() == TILE_COLISIONABLE);   // FIXME: asegurar limites superiores de pantalla!
    }
    
    current_x_ant = current_x;
    current_y_ant = current_y;
    current_x = x;
    current_y = y;
}

void character :: loadAnimations(char *file)
{
     char   buffer[200], bitmapFile[200];
     int    bitmapSizeX, bitmapSizeY;
     int    numAnimaciones;     
     int    velocidad;     
     int    numSprites;
     int    numAsocStates;
     list<string> nameAsocStates;

     // leer fichero animaciones del personaje
     fitxerAnimacio.obrirFitxer(file, LECTURA);

     // cabecera
     fitxerAnimacio.llegirLinea(buffer);
     fitxerAnimacio.llegirLinea(buffer);
     fitxerAnimacio.llegirLinea(buffer);
     fitxerAnimacio.llegirLinea(buffer);         // Linea blanco
     // bitmap
     fitxerAnimacio.llegirParaula(buffer);
     fitxerAnimacio.llegirParaula(bitmapFile);
     fitxerAnimacio.llegirParaula(buffer);
     fitxerAnimacio.llegirEnter(&bitmapSizeX);
     fitxerAnimacio.llegirParaula(buffer);
     fitxerAnimacio.llegirEnter(&bitmapSizeY);
     fitxerAnimacio.llegirLinea(buffer);         // Linea blanco

     animationBitmap.openImage(bitmapFile, bitmapSizeX, bitmapSizeY);

     // animaciones
     fitxerAnimacio.llegirParaula(buffer);
     fitxerAnimacio.llegirEnter(&numAnimaciones);
     fitxerAnimacio.llegirLinea(buffer);         // Linea blanco

     for( int i = 0 ; i < numAnimaciones ; i++ )
     {
         int numFrames;
         fitxerAnimacio.llegirParaula(buffer);
         fitxerAnimacio.llegirParaula(buffer);   // nombre animacion

         fitxerAnimacio.llegirParaula(buffer);
         fitxerAnimacio.llegirEnter(&numAsocStates);

         nameAsocStates.clear();
         for( int k = 0 ; k < numAsocStates ; k++ )
         {
             fitxerAnimacio.llegirParaula(buffer);
             string stateName(buffer);
             
             nameAsocStates.push_back(stateName);
         }
         
         fitxerAnimacio.llegirParaula(buffer);
         fitxerAnimacio.llegirEnter(&numFrames);
                  
         fitxerAnimacio.llegirParaula(buffer);
         fitxerAnimacio.llegirEnter(&velocidad);

         for( list<string>::iterator it = nameAsocStates.begin() ; it != nameAsocStates.end() ; it++ )
         {          
             unsigned int state = stateHandler.GetState(*it);
             animacion[state].numSprites = 0;
             animacion[state].velocidad  = velocidad;
         }
         for( int j = 0; j < numFrames ; j++ )
         {
             int xUpLeft, yUpLeft, xDownRight, yDownRight;
             int estado;
             fitxerAnimacio.llegirParaula(buffer);
             fitxerAnimacio.llegirEnter(&xUpLeft);
             fitxerAnimacio.llegirEnter(&yUpLeft);
             fitxerAnimacio.llegirEnter(&xDownRight);
             fitxerAnimacio.llegirEnter(&yDownRight);
             fitxerAnimacio.llegirEnter(&estado);
             fitxerAnimacio.llegirEnter(&numSprites);

             sprite *spriteAux = new sprite();
             spriteAux->newSprite(&animationBitmap,
                                  xUpLeft, yUpLeft,
                                  xDownRight, yDownRight,
                                  estado, numSprites);   
             for( list<string>::iterator it = nameAsocStates.begin() ; it != nameAsocStates.end() ; it++ )
             {   
                 unsigned int state = stateHandler.GetState(*it);                                 
                 animacion[state].numSprites++;
                 animacion[state].sprites.push_back(spriteAux);
             }
                                               
             for( int k = 0 ; k < numSprites ; k++ )   // composed sprite
             {
                 fitxerAnimacio.llegirParaula(buffer);
                 fitxerAnimacio.llegirEnter(&xUpLeft);
                 fitxerAnimacio.llegirEnter(&yUpLeft);
                 fitxerAnimacio.llegirEnter(&xDownRight);
                 fitxerAnimacio.llegirEnter(&yDownRight);
                 
                 spriteAux->AddInternalSprite(&animationBitmap, xUpLeft, yUpLeft, xDownRight, yDownRight);
             }
         }
     }
}


void character :: computeNextAnimationSprite(unsigned int mseg)
{
    bool trobat = false;
    
    // gestión del tiempo para controlar el cambio de animacion (sprite)
    if( mseg - mseg_chk_anim > animacion[current_state].velocidad )
    {
         subAnimacion++;
         if( subAnimacion == animacion[current_state].sprites.size() )
         {
                subAnimacion = 0;                
                keepMoving = 0; // FIXME : el problema del keepMoving es que no se pone a cero desde los scripts (esto es un truquillo)
         }
         mseg_chk_anim = mseg;
    }
        
    // Seleccion del sprite de la animacion
    int i = 0;
    for( currentSprite = animacion[current_state].sprites.begin() ;
         currentSprite != animacion[current_state].sprites.end() && !trobat; 
       )
    {
         if( i == subAnimacion )
         {
             trobat = true;       
         }       
         else
         {
             i++;    
             currentSprite++;    
         }
    }
    ASSERT( trobat == true );
}

void character :: drawCharacterInWorld(mundo* world, BITMAP* buffer, int posXWorld, int posYWorld)
{
    BITMAP* sprite;
    BITMAP* internal_sprite;
               
    // Informacion para pintar el sprite en el mundo
    int xUpLeft    = (*currentSprite)->xUpLeft;    
    int yUpLeft    = (*currentSprite)->yUpLeft;
    int xDownRight = (*currentSprite)->xDownRight;
    int yDownRight = (*currentSprite)->yDownRight;
    int xSize      = (*currentSprite)->xSize;
    int ySize      = (*currentSprite)->ySize;
    int nComp      = (*currentSprite)->numComponents;

    // Procedemos a pintar
    sprite = create_bitmap(world->GetTileSizeRatio()*xSize, world->GetTileSizeRatio()*ySize); 

    stretch_blit(animationBitmap.getImage(), sprite, xUpLeft, yUpLeft,
                   xSize, ySize,
                   0, 0, world->GetTileSizeRatio()*xSize, world->GetTileSizeRatio()*ySize);   


    if( warrior_sentido == WARRIOR_SENTIDO_DERECHA )
    {
        draw_sprite(buffer, sprite, posXWorld, posYWorld);        // DERECHA                
    }
    else
    {
        draw_sprite_h_flip(buffer, sprite, posXWorld, posYWorld); // IZQUIERDA
    }
    
    // Composed sprite to draw
    for( int i = 0 ; i < nComp ; i++ )
    {
         xSize      = (*currentSprite)->internalSprites[i]->xSize;
         ySize      = (*currentSprite)->internalSprites[i]->ySize;
         xUpLeft    = (*currentSprite)->internalSprites[i]->xUpLeft;    
         yUpLeft    = (*currentSprite)->internalSprites[i]->yUpLeft;

         internal_sprite = create_bitmap(world->GetTileSizeRatio()*xSize, world->GetTileSizeRatio()*ySize);    
         stretch_blit(animationBitmap.getImage(), internal_sprite, xUpLeft, yUpLeft,
                      xSize, ySize,
                      0, 0, world->GetTileSizeRatio()*xSize, world->GetTileSizeRatio()*ySize);   
         
         if( warrior_sentido == WARRIOR_SENTIDO_DERECHA )
         {
             draw_sprite(buffer, internal_sprite, posXWorld + (i + 1)*world->GetTileSizeRatio()*xSize, posYWorld);        // DERECHA
         }
         else
         {
             draw_sprite_h_flip(buffer, internal_sprite, posXWorld - (i + 1)*world->GetTileSizeRatio()*xSize, posYWorld); // IZQUIERDA
         }         
         destroy_bitmap(internal_sprite);
    }
    destroy_bitmap(sprite);       
}

bool character :: SwordCollision(mundo* world, int x, int y, int xSize, int ySize)
{
     if( current_state != WARRIOR_GOLPEANDO )
     {
        return false;
     }
     
     int sign = (warrior_sentido ? world->GetTileSizeRatio()*29 : -(world->GetTileSizeRatio()*12));          // FIXME
     
    if( (current_x + sign > x) &&
        (current_x + sign < (x + world->GetTileSizeRatio()*xSize)) &&
        (current_y + world->GetTileSizeRatio()*8 > y) &&                                       // FIXME
        (current_y + world->GetTileSizeRatio()*8 < (y + world->GetTileSizeRatio()*ySize)) )    // FIXME
    {
        return true;
    }
    
    return false;
}

bool character :: EnemyCollision(BITMAP* buffer, mundo* world, int x, int y, int xSize, int ySize, int sx, int sy)
{
     // Personaje  // FIXME: use constants instead or hardcoded values!!
     int cuadro1_x = current_x + 25;
     int cuadro1_y = current_y + 25;
     int cuadro1_size_x = world->GetTileSizeRatio()*(*currentSprite)->xSize - 50;
     int cuadro1_size_y = world->GetTileSizeRatio()*(*currentSprite)->ySize - 65;

     
     // Enemigo
     int cuadro2_x = x;
     int cuadro2_y = y;
     int cuadro2_size_x = world->GetTileSizeRatio()*xSize;
     int cuadro2_size_y = world->GetTileSizeRatio()*ySize;

     rect(buffer, cuadro1_x - sx - 2, cuadro1_y - sy - 2, cuadro1_x + cuadro1_size_x - sx + 2, cuadro1_y + cuadro1_size_y - sy + 2, 0xF00F);            
     if( (cuadro1_x > cuadro2_x + cuadro2_size_x) || 
         (cuadro1_y > cuadro2_y + cuadro2_size_y) || 
         (cuadro1_x + cuadro1_size_x < cuadro2_x) || 
         (cuadro1_y + cuadro1_size_y < cuadro2_y) )
         return false;

     return true;     
}

void character :: ClearImportantVars()
{
     carrying_object = 0;
}
