// Class automatically generated by Dev-C++ New Class wizard

#include "checkpointhandler.h" // class's header file

// class constructor
checkpointHandler::checkpointHandler()
{
	// insert your code here
}

// class destructor
checkpointHandler::~checkpointHandler()
{
    for( vector<checkpoint*>::iterator it = checkpoints.begin() ; it != checkpoints.end() ; it++ )
    {
         delete *it;
    }
    checkpoints.clear();
}

void checkpointHandler :: loadCheckpointFile(char* file)
{
    char     buffer[200];        
    entradaSortida io;
    
    cout << "==============================================" << endl;
    cout << " Reading checkpoint file " << file << endl;
    
    io.obrirFitxer(file, 0);
    
    io.llegirParaula(buffer);    // numCheckpoints
    io.llegirEnter(&numCheckpoints);
    cout << "\t Num checkpoints " << numCheckpoints << endl;
    
    for( unsigned int i = 0 ; i < numCheckpoints ; i++ )
    {
         int numCheck, nextCheckpoint;
         checkpoint* check = new checkpoint();
         
         io.llegirEnter(&numCheck);
         io.llegirEnter(&(check->x_izq));
         io.llegirEnter(&(check->y_izq));
         io.llegirEnter(&(check->x_der));                  
         io.llegirEnter(&(check->y_der));         
         io.llegirEnter(&(check->warrior_ini_x));
         io.llegirEnter(&(check->warrior_ini_y));
         io.llegirEnter(&nextCheckpoint);
         check->nextCheckpoint.clear();
         while( nextCheckpoint != 0 )
         {
                check->nextCheckpoint.push_back(nextCheckpoint);
                io.llegirEnter(&nextCheckpoint);
         }
         
         cout << "\t\t NumCheck " << numCheck 
              << " i_x " << check->x_izq 
              << " i_y " << check->y_izq 
              << " d_x " << check->x_der 
              << " d_x " << check->y_der 
              << " w_x " << check->warrior_ini_x 
              << " w_y " << check->warrior_ini_y 
              << " next_checks ";
              
         for( list<int>::iterator it = check->nextCheckpoint.begin() ; it != check->nextCheckpoint.end() ; it++ )
         {
              cout << *it << " ";
         }
         cout << endl;
         checkpoints.push_back(check);
    }
    
    lastValidCheckpoint = 0;
    currentCheckpoints.clear();     
    for( list<int>::iterator it = checkpoints[0]->nextCheckpoint.begin() ; it != checkpoints[0]->nextCheckpoint.end() ; it++ )
    {
         currentCheckpoints.push_back(*it);
    }
    cout << "==============================================" << endl;
}

void checkpointHandler :: saveCheckpointFile(char* file)
{
    char     buffer[200];        
    entradaSortida io;
    
    cout << "==============================================" << endl;
    cout << " Saving checkpoint file " << file << endl;
    
    io.obrirFitxer(file, ESCRIPTURA);
    
    io.escriureParaula("numCheckpoints");
    io.escriureEspai();
    io.escriureEnter(checkpoints.size());
    io.escriureEspai();
    io.escriureSaltDeLinia();
    
    int i = 0;
    for( vector<checkpoint*>::iterator it = checkpoints.begin() ; it != checkpoints.end() ; it++ )
    {
         checkpoint* check = *it;
         
         io.escriureEnter(i);
         io.escriureEspai();
         io.escriureEnter(check->x_izq);
         io.escriureEspai();         
         io.escriureEnter(check->y_izq);
         io.escriureEspai();                  
         io.escriureEnter(check->x_der);
         io.escriureEspai();                  
         io.escriureEnter(check->y_der);
         io.escriureEspai();                           
         io.escriureEnter(check->warrior_ini_x);
         io.escriureEspai();                           
         io.escriureEnter(check->warrior_ini_y);
         io.escriureEspai();                           
         for( list<int>::iterator it2 = check->nextCheckpoint.begin() ; it2 != check->nextCheckpoint.end() ; it2++ )
         {
             io.escriureEnter(*it2);
             io.escriureEspai();                                         
         }         
         io.escriureEnter(0);
         io.escriureEspai();              
         io.escriureSaltDeLinia();
         
         i++;
    }
    
    io.tancarFitxer();
    cout << "==============================================" << endl;
}


void checkpointHandler :: PositionedOnNextCheckpoint(int x, int y, int xSize, int ySize)
{
     bool endTest = false;
     for( list<int>::iterator it = currentCheckpoints.begin() ; (it != currentCheckpoints.end()) && (!endTest); it++ )
     {
         bool trobat = false;
         int currentCheckpoint = *it;
         int x_izq = checkpoints[currentCheckpoint]->x_izq;
         int y_izq = checkpoints[currentCheckpoint]->y_izq;
         int x_der = checkpoints[currentCheckpoint]->x_der;
         int y_der = checkpoints[currentCheckpoint]->y_der;     
              
         if( x >= x_izq && x <= x_der &&
             y >= y_izq && y <= y_der  )
         {
             trobat = true;
         }   
    
         if( trobat && currentCheckpoint < (numCheckpoints - 1) )
         {
             endTest = true;
             lastValidCheckpoint = currentCheckpoint;
             currentCheckpoints.clear();     
             for( list<int>::iterator it2 = checkpoints[currentCheckpoint]->nextCheckpoint.begin() ; it2 != checkpoints[currentCheckpoint]->nextCheckpoint.end() ; it2++ )
             {
                  currentCheckpoints.push_back(*it2);
             }          
         }
    }
}

int checkpointHandler :: GetWarriorIniXCurrentCheck() 
{ 
    int current = (lastValidCheckpoint > 0 ? lastValidCheckpoint : 0);
    
    return checkpoints[current]->warrior_ini_x; 
}

int checkpointHandler :: GetWarriorIniYCurrentCheck() 
{ 
    int current = (lastValidCheckpoint > 0 ? lastValidCheckpoint : 0);
    
    return checkpoints[current]->warrior_ini_y; 
}
