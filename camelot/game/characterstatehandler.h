// Class automatically generated by Dev-C++ New Class wizard

#ifndef CHARACTERSTATEHANDLER_H
#define CHARACTERSTATEHANDLER_H

#include <allegro.h>
#include <list>
#include <map>
#include <string>
#include <assert.h>

#include "entradasortida.h"
#include "keyboardmap.h"

#include "defines.h"

#define INPUT_KEY          1
#define INPUT_COL          2
#define INPUT_TIME         3
#define INPUT_DIST_X       4
#define INPUT_DIST_Y       5
#define INPUT_PREV_STATE   6
#define INPUT_STAIRS_LEFT  7
#define INPUT_STAIRS_RIGHT 8

#define LOGOP_EQUAL      1
#define LOGOP_NO_EQUAL   2
#define LOGOP_GREATER    3
#define LOGOP_LOWER      4

#define ACTION_TAKE_MSEG        1
#define ACTION_TAKE_ANIM        2
#define ACTION_TAKE_CHK_PIXEL_X 3
#define ACTION_TAKE_CHK_PIXEL_Y 4
#define ACTION_SET_DIR_LEFT     5
#define ACTION_SET_DIR_RIGHT    6

#define abs(x) (x > 0 ? x : -(x))

using namespace std;

// Prototypes
class characterStateNode;

/*
 * State Transition Condition
 */
class stateTransitionCondition
{
  public:
    unsigned int type;
    unsigned int logicalOp;
    unsigned int condValue;
    string       prevStateName;        // only valid for prev_state condition
    
  public:
    stateTransitionCondition() { ; }
    stateTransitionCondition(unsigned int t, unsigned int op, 
                             unsigned int v, string ps)
    {
        type = t;
        logicalOp = op;
        condValue = v;
        prevStateName = ps;
    }
    ~stateTransitionCondition() { ; }
};

/*
 * State Transition Action
 */
class stateTransitionAction
{
  public:
    unsigned int action;
 
};

/*
 * State Transition
 */
class stateTransition
{
   public:
     list<stateTransitionCondition*> conditions;
     list<stateTransitionAction*>    actions;
     characterStateNode*             nextNode;   
   
   public:              
      stateTransition();
      ~stateTransition();
};

/*
 * Character State Node
 */
class characterStateNode
{
  private:
     string                 name;
     list<stateTransition*> transitions;
  
  public:
     characterStateNode();
     ~characterStateNode();
     
     inline void   SetName(string n) { name = n;    }
     inline string GetName()         { return name; }
     
     inline list<stateTransition*>* GetTransitions() { return &transitions; }
};


/*
 * Character State Handler
 */
class characterStateHandler
{
  private:
    keyboardMap keys;
          
    map<string, unsigned int>              stateNodesDefinition;          
    map<string, characterStateNode*>       stateNodes;
    characterStateNode*                    previousState;
    characterStateNode*                    currentState;
    
    // 
    unsigned int mseg_chk;     // Checkpoint del tiempo. Útil para las animaciones
    unsigned int mseg_chk_anim;
    float pixel_y_chk;         // Checkpoint de la posicion del personaje en un
    float pixel_x_chk;         // momento determinado
    
    // This var avoids state replication depending of direction
    unsigned int direction;
    bool         transitionDone;  // changing state
    
    
  public:		
    characterStateHandler();    // class constructor
    ~characterStateHandler();   // class destructor
    
    bool readDefineStateFromDefinitionFile(entradaSortida &io, char* buffer);
    bool readInitialStateFromDefinitionFile(entradaSortida &io, char* buffer);
    bool readTransitionStateFromDefinitionFile(entradaSortida &io, char* buffer);
    bool openDefinitionFile(char* file);
    
    
    void applyActions(list<stateTransitionAction*> &actions, unsigned int mseg_global, float current_x, float current_y);
    bool handleStateByKey(stateTransitionCondition* condition, unsigned int entrada_teclado);
    bool handleStateByLogicalValue(stateTransitionCondition* condition, bool logical_value);
    bool handleStateByTime(stateTransitionCondition* condition, unsigned int mseg_global);
    bool handleStateByPreviousState(stateTransitionCondition* condition);    
    bool handleStateByDist(stateTransitionCondition* condition, float current_x, float current_y, float current_x_ant, float current_y_ant);
    void handleState(unsigned int entrada_teclado, unsigned int mseg_global, 
                     bool colision_down, bool stairs_left, bool stairs_right, 
                     float current_x, float current_y, float current_x_ant, float current_y_ant);
    
    unsigned int GetCurrentState()   { return stateNodesDefinition[currentState->GetName()];  }
    unsigned int GetPreviousState()  { return stateNodesDefinition[previousState->GetName()]; }
    unsigned int GetDirection()      { return direction;                                      }
    bool         GetTransitionDone() { return transitionDone;                                 }
    unsigned int GetState(string s)  { return stateNodesDefinition[s];                        }

    string GetNameState(unsigned int n);
    
    void SetDirection(unsigned int d)     { direction = d; }
    void SetCurrentState(unsigned int s)  { currentState = stateNodes[this->GetNameState(s)]; }
    void SetPreviousState(unsigned int s) { previousState = stateNodes[this->GetNameState(s)]; }
    
    void ForceCurrentState(unsigned int current_state, unsigned int previous_state);
};

#endif // CHARACTERSTATEHANDLER_H
