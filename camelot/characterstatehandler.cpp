// Class automatically generated by Dev-C++ New Class wizard

#include "characterstatehandler.h" // class's header file

// class constructor
stateTransition :: stateTransition()
{
    conditions.clear();
    actions.clear();
    nextNode = NULL;
}

// class destructor
stateTransition :: ~stateTransition()
{
     for( list<stateTransitionCondition*>::iterator it = conditions.begin() ;
          it != conditions.end() ;
          it++ )
     {
         stateTransitionCondition* condition = *it;
         delete condition;
     }
     for( list<stateTransitionAction*>::iterator it = actions.begin() ;
          it != actions.end() ;
          it++ )
     {
         stateTransitionAction* action = *it;
         delete action;
     }                
}



// class constructor
characterStateNode :: characterStateNode()
{
    transitions.clear();
}

// class destructor
characterStateNode :: ~characterStateNode()
{
    list<stateTransition*>::iterator it;
    for( it = transitions.begin() ; it!= transitions.end(); it++ )
    {
        stateTransition* stateTransitionPtr = *it;
        
        delete stateTransitionPtr;
    }
    transitions.clear();
}

// class constructor
characterStateHandler::characterStateHandler()
{	
    stateNodes.clear();
    
    // This will be removed. This is only valid for the transition period
    // until this class will be fully implemented
    stateNodesDefinition["WARRIOR_PARADO"] = WARRIOR_PARADO;
    stateNodesDefinition["WARRIOR_CAMINANDO"] = WARRIOR_CAMINANDO;
    stateNodesDefinition["WARRIOR_SALTANDO"] = WARRIOR_SALTANDO;
    stateNodesDefinition["WARRIOR_CAYENDO"] = WARRIOR_CAYENDO;
    stateNodesDefinition["WARRIOR_COGER_ESPADA"] = WARRIOR_COGER_ESPADA;
    stateNodesDefinition["WARRIOR_GOLPEANDO"] = WARRIOR_GOLPEANDO;
    stateNodesDefinition["WARRIOR_EN_GUARDIA"] = WARRIOR_EN_GUARDIA;
    stateNodesDefinition["WARRIOR_AGACHADO"] = WARRIOR_AGACHADO;  
    stateNodesDefinition["WARRIOR_EN_ESCALERAS_LEFT_PARADO"] = WARRIOR_EN_ESCALERAS_LEFT_PARADO;        
    stateNodesDefinition["WARRIOR_EN_ESCALERAS_LEFT_CAMINANDO"] = WARRIOR_EN_ESCALERAS_LEFT_CAMINANDO;        
    stateNodesDefinition["WARRIOR_EN_ESCALERAS_RIGHT_PARADO"] = WARRIOR_EN_ESCALERAS_RIGHT_PARADO;        
    stateNodesDefinition["WARRIOR_EN_ESCALERAS_RIGHT_CAMINANDO"] = WARRIOR_EN_ESCALERAS_RIGHT_CAMINANDO;            
    stateNodesDefinition["WARRIOR_RANA_PARADO"] = WARRIOR_RANA_PARADO;
    stateNodesDefinition["WARRIOR_RANA_CAMINANDO"] = WARRIOR_RANA_CAMINANDO;
    stateNodesDefinition["WARRIOR_RANA_SALTANDO"] = WARRIOR_RANA_SALTANDO;
    stateNodesDefinition["WARRIOR_RANA_CAYENDO"] = WARRIOR_RANA_CAYENDO;
}

// class destructor
characterStateHandler::~characterStateHandler()
{
    map<string, characterStateNode*>::iterator it; 
    for( it = stateNodes.begin() ; it != stateNodes.end() ; it++ )
    {
        characterStateNode* characterStateNodePtr = it->second;
        
        delete characterStateNodePtr;
    }
    
    stateNodes.clear();
}

bool characterStateHandler::readDefineStateFromDefinitionFile(entradaSortida &io, char* buffer)
{
    // Read states from defition file
    io.llegirParaula(buffer);
    if( strcmp(buffer, "#define") != 0 )  // check that file starts with #def
    {
        cout << "#define token found: " << buffer << endl;
        return false;
    }    
    do                                   // all #def loops
    {                
        io.llegirParaula(buffer);                     
        string state_name(buffer);
        if( stateNodes.count(state_name) != 0 ) // only one #def per state
        {
            cout << "state " << state_name << " redefinition " << endl;
            return false;
        }
        // Reserve memory for state and link it by the map structure
        characterStateNode* stateNode = new characterStateNode();
        stateNode->SetName(state_name);
        stateNodes[state_name] = stateNode;

        io.llegirParaula(buffer);
    } while( strcmp(buffer, "#define") == 0 );
    
    return true;        
}

bool characterStateHandler::readInitialStateFromDefinitionFile(entradaSortida &io, char* buffer)
{
    // Read initial state from defition file
    if( strcmp(buffer, "#initial_state") != 0 )
    {
        cout << "#initial_state token not found:" << buffer << endl;
        return false;
    }
    // Read previous state
    io.llegirParaula(buffer);
    string previous_state_name(buffer);
    if( stateNodes.count(previous_state_name) == 0 )
    {
        cout << "Bad previous initial state definition:" << previous_state_name << endl;
        return false;
    }
    previousState = stateNodes[previous_state_name];    
    
    // Read current state
    io.llegirParaula(buffer);
    string initial_state_name(buffer);
    if( stateNodes.count(initial_state_name) == 0 )
    {
        cout << "Bad initial state definition:" << initial_state_name << endl;
        return false;
    }
    currentState  = stateNodes[initial_state_name];     
        
    return true;
}

bool characterStateHandler::readTransitionStateFromDefinitionFile(entradaSortida &io, char* buffer)
{
    unsigned int     num_conditions;
    unsigned int     num_actions;
    unsigned int     condition_type;
    unsigned int     logical_operator;
    unsigned int     condition_value;
    unsigned int     action;
    string           prev_state_name;
    stateTransition* transition;
        
    // Read transition from defition file
    io.llegirParaula(buffer);
    if( strcmp(buffer, "#transition") != 0 )  // check that file starts with #t
    {
        cout << "#define token found: " << buffer << endl;
        return false;
    }    
    do                                   // all #transition loop
    {                
        transition = new stateTransition();                     
        
        io.llegirParaula(buffer);                     
        string orig_state_name(buffer);
        if( stateNodes.count(orig_state_name) == 0 ) // only one #def per state
        {
            cout << "state " << orig_state_name << " not defined in transition " << endl;
            return false;
        }
        io.llegirParaula(buffer);                     
        string dest_state_name(buffer);
        if( stateNodes.count(dest_state_name) == 0 ) // only one #def per state
        {
            cout << "state " << dest_state_name << " not defined in transition " << endl;
            return false;
        }        
                
        io.llegirParaula(buffer);
        num_conditions = atoi(buffer);
        for( unsigned int i = 0 ; i < num_conditions ; i++ )
        {
             io.llegirParaula(buffer);  // condition type
             if( strcmp(buffer, "key") == 0 )
             {
                 condition_type = INPUT_KEY;
             }
             else if( strcmp(buffer, "col") == 0 )
             {
                 condition_type = INPUT_COL;
             }             
             else if( strcmp(buffer, "stairs_left") == 0 )
             {
                 condition_type = INPUT_STAIRS_LEFT;
             }                          
             else if( strcmp(buffer, "stairs_right") == 0 )
             {
                 condition_type = INPUT_STAIRS_RIGHT;
             }                                       
             else if( strcmp(buffer, "time") == 0 )
             {
                 condition_type = INPUT_TIME;
             }                          
             else if( strcmp(buffer, "dist_x") == 0 )
             {
                 condition_type = INPUT_DIST_X;
             }   
             else if( strcmp(buffer, "dist_y") == 0 )
             {
                 condition_type = INPUT_DIST_Y;
             }        
             else if( strcmp(buffer, "prev_state") == 0 )
             {
                 condition_type = INPUT_PREV_STATE;
             }                                                                                                             
             else
             {
                 cout << "no valid condition type in transition: " << buffer << endl;
                 return false;
             }
             
             io.llegirParaula(buffer);  // operator
             if( strcmp(buffer, "=") == 0 )
             {
                 logical_operator = LOGOP_EQUAL;
             }
             else if( strcmp(buffer, "!") == 0 )
             {
                 logical_operator = LOGOP_NO_EQUAL;                  
             }
             else if( strcmp(buffer, "<") == 0 )
             {
                 logical_operator = LOGOP_LOWER;                                    
             }
             else if( strcmp(buffer, ">") == 0 )
             {
                 logical_operator = LOGOP_GREATER;                                    
             }
             else
             {
                 cout << "no valid operator type in transition: " << buffer << endl;
                 return false;
             }
             
             io.llegirParaula(buffer); 
             if( condition_type == INPUT_KEY )
             {
                 string key_value(buffer);
                 condition_value = keys.GetKey(key_value);
             }        
             else if( condition_type == INPUT_COL    || 
                      condition_type == INPUT_TIME   ||
                      condition_type == INPUT_DIST_X ||
                      condition_type == INPUT_DIST_Y ||
                      condition_type == INPUT_STAIRS_LEFT ||
                      condition_type == INPUT_STAIRS_RIGHT )
             {
                 condition_value = atoi(buffer);
             }
             else if( condition_type == INPUT_PREV_STATE )
             {
                  string aux(buffer);
                  condition_value = 0;
                  prev_state_name = aux;
             }
             
             // Create condition for this transition
             stateTransitionCondition* condition = 
                 new stateTransitionCondition(condition_type, 
                                              logical_operator,
                                              condition_value,
                                              prev_state_name);
             
             transition->conditions.push_back(condition);             
        }

        io.llegirParaula(buffer); // actions
        num_actions = atoi(buffer);
        for( unsigned int i = 0 ; i < num_actions ; i++ )
        {
            io.llegirParaula(buffer);
            if( strcmp(buffer, "TAKE_MSEG") == 0 )
            {
                action = ACTION_TAKE_MSEG;
            }
            else if( strcmp(buffer, "TAKE_ANIM") == 0 )
            {
                action = ACTION_TAKE_ANIM;                
            }
            else if( strcmp(buffer, "TAKE_CHK_PIXEL_X") == 0 )
            {
                action = ACTION_TAKE_CHK_PIXEL_X;                
            }
            else if( strcmp(buffer, "TAKE_CHK_PIXEL_Y") == 0 )
            {
                action = ACTION_TAKE_CHK_PIXEL_Y;                
            }    
            else if( strcmp(buffer, "SET_DIR_LEFT") == 0 )
            {
                action = ACTION_SET_DIR_LEFT;
            }
            else if( strcmp(buffer, "SET_DIR_RIGHT") == 0 )
            {
                action = ACTION_SET_DIR_RIGHT;
            }            
            else
            {
                cout << "no valid action type in transition: " << buffer << endl;
                return false;                
            }
            stateTransitionAction* actionPtr = new stateTransitionAction();
            actionPtr->action = action;
            transition->actions.push_back(actionPtr);       
        }
        
        // Add transition to its node
        transition->nextNode = stateNodes[dest_state_name];
        stateNodes[orig_state_name]->GetTransitions()->push_back(transition);
        
        io.llegirParaula(buffer);
    } while( strcmp(buffer, "#transition") == 0 );     
}

bool characterStateHandler::openDefinitionFile(char* file)
{
    char buffer[50];    
    entradaSortida io;
    
    io.obrirFitxer(file, LECTURA);
    
    cout << "=============================================="     << endl;
    cout << " Reading state behaviour definition file "  << file << endl;
    
    if( !this->readDefineStateFromDefinitionFile(io, buffer) )
    {
        cout << "\t Error in definition step " << endl;
        return false;
    }
    if( !this->readInitialStateFromDefinitionFile(io, buffer) )
    {
        cout << "\t Error reading initial state " << endl;
        return false;
    }
    if( !this->readTransitionStateFromDefinitionFile(io, buffer) )
    {
        cout << "\t Error reading transitions state " << endl;
        return false;
    }

    // Resum of all loaded information
    map<string, characterStateNode*>::iterator it; 
    for( it = stateNodes.begin() ; it != stateNodes.end() ; it++ )
    {
        characterStateNode* characterStateNodePtr = it->second;
        
        cout << "\t State " << it->first << " with transitions " << endl;
        for( list<stateTransition*>::iterator it = characterStateNodePtr->GetTransitions()->begin() ;
             it != characterStateNodePtr->GetTransitions()->end() ;
             it++ )
        {
             stateTransition* transition = *it;
             
             cout << "\t\t Conditions: " << endl;
             for( list<stateTransitionCondition*>::iterator it_cond = transition->conditions.begin() ;
                  it_cond != transition->conditions.end() ;
                  it_cond++ )
             {
                  stateTransitionCondition* condition = *it_cond;
                  
                  cout << "\t\t\t type = " << condition->type
                       << " operator "     << condition->logicalOp
                       << " value "        << condition->condValue
                       << " prev_state "   << condition->prevStateName
                       << endl;
             }
             cout << "\t\t Actions: " << endl;
             for( list<stateTransitionAction*>::iterator it_cond = transition->actions.begin() ;
                  it_cond != transition->actions.end() ;
                  it_cond++ )
             {
                  stateTransitionAction* actionPtr = *it_cond;
                  
                  cout << "\t\t\t type = " << actionPtr->action << endl;
             }
             cout << "\t\t To state: " << transition->nextNode->GetName() << endl;
        }
    }
    cout << "\t Initial state set to " << currentState->GetName() << endl;
    
    cout << "==============================================" << endl;
    
    io.tancarFitxer();
}

bool characterStateHandler :: handleStateByKey(stateTransitionCondition* condition, unsigned int entrada_teclado)
{
    assert( condition->type == INPUT_KEY );

    if( condition->logicalOp == LOGOP_EQUAL )
    {
        // Special case
        if( (condition->condValue & entrada_teclado) == 0 )
        {
            return false;
        }
    }
    else if( condition->logicalOp == LOGOP_NO_EQUAL )
    {
        if( (condition->condValue & entrada_teclado) == 1 )
        {
            return false;
        }  
    }
    
    return true;
}

bool characterStateHandler :: handleStateByLogicalValue(stateTransitionCondition* condition, bool logicalValue)
{
    if( condition->logicalOp == LOGOP_EQUAL )
    {
        if( logicalValue != condition->condValue )
        {            
            return false;
        }
    }
    else if( condition->logicalOp == LOGOP_NO_EQUAL )
    {
        if( logicalValue == condition->condValue )
        {
            return false;
        }                        
    }
    
    return true;
}

bool characterStateHandler :: handleStateByTime(stateTransitionCondition* condition, unsigned int mseg_global)
{
    if( condition->logicalOp == LOGOP_GREATER )
    {
        if( mseg_global - mseg_chk <= condition->condValue )
        {
            return false;
        }
    }
    else if( condition->logicalOp == LOGOP_LOWER )
    {
        if( mseg_global - mseg_chk > condition->condValue )
        {
            return false;
        }
    }
    // TODO
    
    return true;
}

bool characterStateHandler :: handleStateByPreviousState(stateTransitionCondition* condition)
{
    if( condition->logicalOp == LOGOP_EQUAL )
    {
        if( strcmp(condition->prevStateName.c_str(), previousState->GetName().c_str()) != 0 )
        {
            return false;
        }
    }
    else if( condition->logicalOp == LOGOP_NO_EQUAL )
    {
        if( strcmp(condition->prevStateName.c_str(), previousState->GetName().c_str()) == 0 )
        {
            return false;
        }  
    }
    
    return true;     
}

bool characterStateHandler :: handleStateByDist(stateTransitionCondition* condition, float current_x, float current_y, float current_x_ant, float current_y_ant)
{
    float diff = 0;
    
    // If there is no movement then return true directly
    if( (current_x == current_x_ant) && (current_y == current_y_ant) )
    {
        return true;
    }
    
    if( condition->type == INPUT_DIST_X )
    {
        diff = abs(pixel_x_chk - current_x);
    }
    else
    {
        diff = abs(pixel_y_chk - current_y);
    }

    if( condition->logicalOp == LOGOP_GREATER )
    {
        if( diff <= condition->condValue )
        {       
            return false;
        }
    }
    else if( condition->logicalOp == LOGOP_LOWER )
    {
        if( diff > condition->condValue )
        {
            return false;
        }
    }
    // TODO
    
    return true;     
}

void characterStateHandler :: applyActions(list<stateTransitionAction*> &actions, unsigned int mseg_global, float current_x, float current_y)
{
    for( list<stateTransitionAction*>::iterator it_cond = actions.begin() ;
         it_cond != actions.end() ;
         it_cond++ )
    {
        stateTransitionAction* actionPtr = *it_cond;
        
        if( actionPtr->action == ACTION_TAKE_MSEG )
        {
            mseg_chk = mseg_global;
        }
        else if( actionPtr->action == ACTION_TAKE_ANIM )
        {        
            mseg_chk_anim = mseg_global - 1000;
        }
        else if( actionPtr->action == ACTION_TAKE_CHK_PIXEL_X )
        {
             pixel_x_chk = current_x;
        }
        else if( actionPtr->action == ACTION_TAKE_CHK_PIXEL_Y )
        {
             pixel_y_chk = current_y;
        }
        else if( actionPtr->action == ACTION_SET_DIR_LEFT )
        {
             direction = WARRIOR_SENTIDO_IZQUIERDA;
        }
        else if( actionPtr->action == ACTION_SET_DIR_RIGHT )
        {
             direction = WARRIOR_SENTIDO_DERECHA;
        }        
    }
}

void characterStateHandler :: handleState(
     unsigned int entrada_teclado, 
     unsigned int mseg_global, 
     bool colision_down, 
     bool stairs_left, 
     bool stairs_right, 
     float current_x, 
     float current_y, 
     float current_x_ant, 
     float current_y_ant)
{
     bool allConditionsTrue;
         
     for( list<stateTransition*>::iterator it = currentState->GetTransitions()->begin() ;
          it != currentState->GetTransitions()->end() ;
          it++ )
     {
          stateTransition* transition = *it;          
          
          allConditionsTrue = (bool)transition->conditions.size();
          for( list<stateTransitionCondition*>::iterator it_cond = transition->conditions.begin() ;
               (it_cond != transition->conditions.end()) && allConditionsTrue ;
               it_cond++ )
          {
               stateTransitionCondition* condition = *it_cond;
                              
               if( condition->type == INPUT_KEY )
               {
                   allConditionsTrue = this->handleStateByKey(condition, entrada_teclado);
               }               
               else if( condition->type == INPUT_COL )
               { 
                   allConditionsTrue = this->handleStateByLogicalValue(condition, colision_down);
               }            
               else if( condition->type == INPUT_STAIRS_LEFT )
               { 
                   allConditionsTrue = this->handleStateByLogicalValue(condition, stairs_left);
               }                           
               else if( condition->type == INPUT_STAIRS_RIGHT )
               { 
                   allConditionsTrue = this->handleStateByLogicalValue(condition, stairs_right);
               }                                          
               else if( condition->type == INPUT_TIME )
               {
                   allConditionsTrue = this->handleStateByTime(condition, mseg_global);
               }    
               else if( condition->type == INPUT_PREV_STATE )
               {
                   allConditionsTrue = this->handleStateByPreviousState(condition);
               }           
               else if( condition->type == INPUT_DIST_X || condition->type == INPUT_DIST_Y )
               {
                   allConditionsTrue = this->handleStateByDist(condition, current_x, current_y, current_x_ant, current_y_ant);
               }
          }
          
          transitionDone = false;
          if( allConditionsTrue )
          {
              this->applyActions(transition->actions, mseg_global, current_x, current_y);
              if( currentState != transition->nextNode )
              {
                  transitionDone = true;
                  previousState = currentState;                  
              }
              currentState  = transition->nextNode;
              return;
          }
     }
     
}

string characterStateHandler :: GetNameState(unsigned int n)
{
     for( map<string, unsigned int>::iterator it = stateNodesDefinition.begin() ;
          it != stateNodesDefinition.end() ;
          it++ )
     {       
             if( it->second == n )
             {
                 return it->first;
             }
     }
     
     assert(false);
}

void characterStateHandler :: ForceCurrentState(unsigned int current_state, unsigned int previous_state)
{
     string cs;
     string ps;
     
     for( map<string, unsigned int>::iterator it = stateNodesDefinition.begin() ;
          it != stateNodesDefinition.end() ;
          it++ )
     {
          if( current_state == it->second )
          {
              cs = it->first;
          }
          if( previous_state == it->second )
          {
              ps = it->first;
          }
     }
     
     currentState  = stateNodes[cs];
     previousState = stateNodes[ps];
}
