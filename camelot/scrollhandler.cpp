// Class automatically generated by Dev-C++ New Class wizard

#include "scrollhandler.h" // class's header file

scrollInfo::scrollInfo()
{
    scrollStartX = 0;
    scrollStartY = 0;
    
    worldSizeX  = 0;
    worldSizeY  = 0;
    screenSizeX = 0;
    screenSizeY = 0;                        
}

scrollInfo::~scrollInfo()
{
}

// class constructor
ScrollHandler::ScrollHandler()
{        
    screenCoordX  = 0;
    screenCoordY  = 0;
    warriorCoordX = 0;
    warriorCoordY = 0;
    warriorSentido = 0;
    
    stateX = 0;
    stateY = 0;       
    state  = NORMAL;
    
    fastVelX = 0;
    fastVelY = 0;                                       
}

// class destructor
ScrollHandler::~ScrollHandler()
{
}

void ScrollHandler :: init(char *file, 
  unsigned int ssx, unsigned int ssy,
  unsigned int wcx, unsigned int wcy, unsigned int ws, 
  unsigned int fvx, unsigned int fvy)
{
    entradaSortida fitxer;             
    char buffer[200];
    int numZones = 0;
    int zone = 0;    
    
    assert( fitxer.obrirFitxer(file, LECTURA) == true );
    
    fitxer.llegirParaula(buffer); 
    fitxer.llegirEnter(&numZones);
    fitxer.llegirParaula(buffer);
    fitxer.llegirEnter(&zone);    
    cout << " ================================= " << endl;
    cout << " = Reading zones : " << file << endl;
    cout << " = ------------------------------- " << endl;
    cout << " = NumZones = " << numZones << endl;
    cout << " = CurrentZone = " << zone << endl;
    
    for( unsigned int i = 0 ; i < numZones ; i++ )
    {
        cout << " = Info zone " << i << endl;
        int sstartx = 0;
        int sstarty = 0;
        int wsx = 0;
        int wsy = 0;
        
        fitxer.llegirParaula(buffer);
        fitxer.llegirEnter(&sstartx);                 
        fitxer.llegirParaula(buffer);
        fitxer.llegirEnter(&sstarty);                         
        fitxer.llegirParaula(buffer);
        fitxer.llegirEnter(&wsx);                         
        fitxer.llegirParaula(buffer);
        fitxer.llegirEnter(&wsy);                         
        
        cout << " start_x " << sstartx 
             << " start_y " << sstarty 
             << " wsx " << wsx << " wsy " << wsy << " ssx " 
             << ssx << " ssy " << ssy << endl;
             
        scrollLimitsInfo[i].scrollStartX = sstartx;           
        scrollLimitsInfo[i].scrollStartY = sstarty;
        scrollLimitsInfo[i].worldSizeX   = wsx;
        scrollLimitsInfo[i].worldSizeY   = wsy;
        scrollLimitsInfo[i].screenSizeX  = ssx;
        scrollLimitsInfo[i].screenSizeY  = ssy;
    }
    cout << " ================================= " << endl;    
    
    screenCoordX  = scrollLimitsInfo[zone].scrollStartX;
    screenCoordY  = scrollLimitsInfo[zone].scrollStartY;
    warriorCoordX = wcx;
    warriorCoordY = wcy;
    warriorSentido = ws;
    
    stateX = RECOMPUTE_SCROLL_X;
    stateY = RECOMPUTE_SCROLL_Y;     
    
    fastVelX = fvx;
    fastVelY = fvy;          
    
    currentScrollInfo = zone;     
    currentScrollZones = numZones;
}

void ScrollHandler :: normalScrollX(unsigned int wcx, unsigned int wcy, unsigned int ws, int &scx, int &scy, int &wscx, int &wscy)
{
    unsigned int ssx = scrollLimitsInfo[currentScrollInfo].screenSizeX;
    unsigned int wsx = scrollLimitsInfo[currentScrollInfo].worldSizeX;
    unsigned int sstartx = scrollLimitsInfo[currentScrollInfo].scrollStartX;

    scx = wcx - (ssx >> 1);

    if( scx <= (int)(sstartx) )
    {
        scx = sstartx;
    }
    else if( scx > (sstartx + wsx - ssx) )
    {
        scx = sstartx + wsx - ssx;
    }
    
    wscx = wcx - scx;    
    //assert( wscx >= 0 );    // FIXME
}

void ScrollHandler :: normalScrollY(unsigned int wcx, unsigned int wcy, unsigned int ws, int &scx, int &scy, int &wscx, int &wscy)
{
    unsigned int ssy = scrollLimitsInfo[currentScrollInfo].screenSizeY;
    unsigned int wsy = scrollLimitsInfo[currentScrollInfo].worldSizeY;
    unsigned int sstarty = scrollLimitsInfo[currentScrollInfo].scrollStartY;     

    scy = wcy - (ssy >> 1);        
    
    if( scy <= (int)(sstarty) )
    {
        scy = sstarty;
    }
    else if( scy > (sstarty + wsy - ssy) )
    {
        scy = sstarty + wsy - ssy;
    }        
    
    wscy = wcy - scy;    
    assert( wscy >= 0 );
}

void ScrollHandler :: normalScroll(unsigned int wcx, unsigned int wcy, unsigned int ws, int &scx, int &scy, int &wscx, int &wscy)
{          
    this->normalScrollX(wcx, wcy, ws, scx, scy, wscx, wscy);
    this->normalScrollY(wcx, wcy, ws, scx, scy, wscx, wscy);
}

void ScrollHandler :: fastScroll(unsigned int wcx, unsigned int wcy, unsigned int ws, int &scx, int &scy, int &wscx, int &wscy)
{      
    bool endFastScrollX = false;
    bool endFastScrollY = false;
    unsigned int ssx = scrollLimitsInfo[currentScrollInfo].screenSizeX;
    unsigned int ssy = scrollLimitsInfo[currentScrollInfo].screenSizeY;
    unsigned int wsx = scrollLimitsInfo[currentScrollInfo].worldSizeX;
    unsigned int wsy = scrollLimitsInfo[currentScrollInfo].worldSizeY;
    unsigned int sstartx = scrollLimitsInfo[currentScrollInfo].scrollStartX;
    unsigned int sstarty = scrollLimitsInfo[currentScrollInfo].scrollStartY;
        
    if( stateX == NORMAL_ADVANCE_RIGHT || stateX == NORMAL_ADVANCE_LEFT )
    {
        endFastScrollX = true;        
        this->normalScrollX(wcx, wcy, ws, scx, scy, wscx, wscy);
    }
    else if( stateX == FAST_ADVANCE_RIGHT )
    {
        if( scx < savedScreenCoordX )
        {
            scx += fastVelX;
        }        
        else
        {
            scx = savedScreenCoordX;
            endFastScrollX = true;
            stateX = NORMAL_ADVANCE_RIGHT;
        }
    }
    else if( stateX == FAST_ADVANCE_LEFT )
    {
        if( scx > savedScreenCoordX )
        {
            if( scx - fastVelX >= 0 )
                scx -= fastVelX;
            else
                scx = 0;
        }        
        else
        {
            endFastScrollX = true;
            stateX = NORMAL_ADVANCE_LEFT;
        }
    }

    if( stateY == NORMAL_ADVANCE_UP || stateY == NORMAL_ADVANCE_DOWN )
    {
        endFastScrollY = true;        
        this->normalScrollY(wcx, wcy, ws, scx, scy, wscx, wscy);
    }
    else if( stateY == FAST_ADVANCE_DOWN )
    {
        if( scy < savedScreenCoordY )
        {
            scy += fastVelY;
        }        
        else
        {
            endFastScrollY = true;
            stateY = NORMAL_ADVANCE_DOWN;
        }
    }
    else if( stateY == FAST_ADVANCE_UP )
    {
        if( scy > savedScreenCoordY )
        {
            if( scy - fastVelY >= 0 )
                scy -= fastVelY;
            else
                scy = 0;
        }        
        else
        {
            endFastScrollY = true;
            stateY = NORMAL_ADVANCE_UP;
        }
    }        

    
    if( endFastScrollX && endFastScrollY )
    {
         state = NORMAL;
    }
    
    if( scx < 0 )
        scx = 0;
    if( scy < 0 )
        scy = 0;
    
    wscx = wcx - scx;
    wscy = wcy - scy;
}



void ScrollHandler :: supervisor(unsigned int wcx, unsigned int wcy, unsigned int ww, unsigned int ws, int &scx, int &scy, int &wscx, int &wscy)
{
    bool trobat = false;
    unsigned int currentZone = 0;
    unsigned int wsx;
    unsigned int wsy;
    unsigned int sstartx;
    unsigned int sstarty;     
    
    if( ws == WARRIOR_SENTIDO_IZQUIERDA )
        ww = 0;
    
    for( unsigned int i = 0 ; (i < currentScrollZones) && (!trobat) ; i++ )
    {  
        wsx = scrollLimitsInfo[i].worldSizeX;
        wsy = scrollLimitsInfo[i].worldSizeY;
        sstartx = scrollLimitsInfo[i].scrollStartX;
        sstarty = scrollLimitsInfo[i].scrollStartY;     
        
        if( (wcx + ww >= sstartx) && (wcx + ww <= sstartx + wsx) && 
            (wcy >= sstarty) && (wcy <= sstarty + wsy) )
        {
            trobat = true;
            currentZone = i;
        }
    }
    
    if( currentZone != currentScrollInfo )
    {
         unsigned int scx_old = scx;
         unsigned int scy_old = scy;
         unsigned int wscx_old = wscx;
         unsigned int wscy_old = wscy;
         
         currentScrollInfo = currentZone;
         this->normalScroll(wcx, wcy, ws, scx, scy, wscx, wscy);
         savedScreenCoordX = scx;
         savedScreenCoordY = scy;
         scx = scx_old;
         scy = scy_old;
         wscx_old = wscx;
         wscy_old = wscy;
         
         state = FAST_ADVANCE;                  
         if( scx < savedScreenCoordX )
             stateX = FAST_ADVANCE_RIGHT;
         else 
             stateX = FAST_ADVANCE_LEFT;         
         if( scy < savedScreenCoordY )
             stateY = FAST_ADVANCE_DOWN;
         else 
             stateY = FAST_ADVANCE_UP;                     
    }
    
    // State machine
    if( state == NORMAL )
    {
        this->normalScroll(wcx, wcy, ws, scx, scy, wscx, wscy);
    }
    else if( state == FAST_ADVANCE )
    {
        this->fastScroll(wcx, wcy, ws, scx, scy, wscx, wscy);   
    }
}


/*
// FIXME : I am working on this scroll technique. It has still some pending bugs and I have to change the trigger distances
//         It is important to implement the modification already done in the basic scroll handler function
void ScrollHandler :: newHandler(unsigned int wcx, unsigned int wcy, unsigned int ws, int &scx, int &scy, int &wscx, int &wscy)
{
    int wscx_current = wcx - scx;
    int wscy_current = wcy - scy;    
    
    if( stateX == RECOMPUTE_SCROLL_X )
    {
    cout << " RECOMPUTE " << endl;
        if( (wscx_current > ((3*screenSizeX)/4)) && (ws == WARRIOR_SENTIDO_DERECHA) )
        {
            cout << " HACIA LA DERECHA " << endl;
            stateX = FAST_ADVANCE_RIGHT;
        }
        if( (wscx_current < (screenSizeX/4)) && (ws == WARRIOR_SENTIDO_IZQUIERDA) )
        {
            cout << " HACIA LA IZQUIERDA " << endl;
            stateX = FAST_ADVANCE_LEFT;
        }        
    }
    else if( stateX == FAST_ADVANCE_RIGHT )
    {
         if( ws != warriorSentido )
         {
            stateX = RECOMPUTE_SCROLL_X;
         }
         else if( (wscx_current > ((screenSizeX/2) - fastVelX)) && (wscx_current < ((screenSizeX/2) + fastVelX)) )
         {
             stateX = NORMAL_ADVANCE_RIGHT;
         }
         else
         {
             scx += fastVelX;
             if( scx > (worldSizeX - screenSizeX) )
             {
                 scx = (worldSizeX - screenSizeX);
             }
         }
    }
    else if( stateX == NORMAL_ADVANCE_RIGHT )
    {
        if( ws != warriorSentido )
        {
            stateX = RECOMPUTE_SCROLL_X;
        }
        else
        {
            scx = wcx - (screenSizeX/2);
            wscx = (screenSizeX/2);
            if( scx > (worldSizeX - screenSizeX) )
            {
                scx = worldSizeX - screenSizeX;
                wscx += (screenSizeX/2) - (worldSizeX - screenSizeX);
            }         
        }

    }
    else if( stateX == FAST_ADVANCE_LEFT )
    {
         if( ws != warriorSentido )
         {
            stateX = RECOMPUTE_SCROLL_X;            
         }
         else if( (wscx_current > ((screenSizeX/2) - fastVelX)) && (wscx_current < ((screenSizeX/2) + fastVelX)) )
         {
             stateX = NORMAL_ADVANCE_LEFT;
         }
         else
         {
             scx -= fastVelX;
             if( scx <= 0 )
             {
                 scx = 0;
             }
         }
    }
    else if( stateX == NORMAL_ADVANCE_LEFT )
    {
        if( ws != warriorSentido )
        {
            stateX = RECOMPUTE_SCROLL_X;
            
        }
        else
        {
            scx = wcx - (screenSizeX/2);
            wscx = (screenSizeX/2);
            if( scx <= 0 )
            {
                scx = 0;
                wscx = wcx;
            }            
        }
    }
    
    wscx = wscx_current;    
    
    scy = wcy - (screenSizeY/2);
    wscy = (screenSizeY/2);
    if( scy <= 0 )
    {
        scy = 0;
        wscy = wcy;
    }
    else if( scy > (worldSizeY - screenSizeY) )
    {
        scy = worldSizeY - screenSizeY;
        wscy += (screenSizeY/2) - (worldSizeY - screenSizeY);
    }        
    
    screenCoordX  = scx;
    screenCoordY  = scy;
    warriorCoordX = wcx;
    warriorCoordY = wcy;
    warriorSentido = ws;
}

*/
